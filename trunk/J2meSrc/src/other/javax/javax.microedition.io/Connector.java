// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sun Feb 29 19:10:55 CET 2004
package other.javax.javax.microedition;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;

/**
 * This class is factory for creating new Connection objects.
 * 
 * This class is factory for creating new Connection objects.
 * <p>
 * The creation of Connections is performed dynamically by looking
 * up a protocol implementation class whose name is formed from the
 * platform name (read from a system property) and the protocol name
 * of the requested connection (extracted from the parameter string
 * supplied by the application programmer.)
 * 
 * The parameter string that describes the target should conform
 * to the URL format as described in RFC 2396.
 * This takes the general form:
 * <p>
 * <code>{scheme}://[{target}][{parms}]</code>
 * <p>
 * where <code>{scheme}</code> is the name of a protocol such as
 * <i>http</i>}.
 * <p>
 * The <code>{target}</code> is normally some kind of network
 * address.
 * <p>
 * Any <code>{parms}</code> are formed as a series of equates
 * of the form ";x=y".  Example: ";type=a".
 * <p>
 * An optional second parameter may be specified to the open
 * function. This is a mode flag that indicates to the protocol
 * handler the intentions of the calling code. The options here
 * specify if the connection is going to be read (READ), written
 * (WRITE), or both (READ_WRITE). The validity of these flag
 * settings is protocol dependent. For instance, a connection
 * for a printer would not allow read access, and would throw
 * an IllegalArgumentException. If the mode parameter is not
 * specified, READ_WRITE is used by default.
 * <p>
 * An optional third parameter is a boolean flag that indicates
 * if the calling code can handle timeout exceptions. If this
 * flag is set, the protocol implementation may throw an
 * InterruptedIOException when it detects a timeout condition.
 * This flag is only a hint to the protocol handler, and it
 * does not guarantee that such exceptions will actually be thrown.
 * If this parameter is not set, no timeout exceptions will be
 * thrown.
 * <p>
 * Because connections are frequently opened just to gain access
 * to a specific input or output stream, four convenience
 * functions are provided for this purpose.
 * 
 * See also: <A HREF="../../../javax/microedition/io/DatagramConnection.html"><CODE>DatagramConnection</CODE></A>
 * for information relating to datagram addressing
 * <HR>
 * 
 * 
 * @since CLDC 1.0
 */
public class Connector extends Object
{
	/**
	 * Access mode
	 */
	public static final int READ = 1;

	/**
	 * Access mode
	 */
	public static final int WRITE = 2;

	/**
	 * Access mode
	 */
	public static final int READ_WRITE = 3;

//    private static Map schemaToConnectionImplementationMapping;
    
//    static {
//        schemaToConnectionImplementationMapping = new HashMap();
//        schemaToConnectionImplementationMapping.put("http",HttpConnectionImpl.class);
//        schemaToConnectionImplementationMapping.put("https",HttpConnectionImpl.class);
//    }
    
    
	/**
	 * Create and open a Connection.
     * This class currently supports http based URLs only.
	 * 
	 * @param url - The URL for the connection.
	 * @return A new Connection object.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the requested connection cannot be make, or the protocol type does not exist.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static Connection open(String url) throws IOException
	{
        if(url == null){
            throw new IllegalArgumentException("ERROR:Connector.open(...):Parameter 'url' is null.");
        }
//        // TODO: maybe use URL for parsing.
//       StringTokenizer tokenizer = new StringTokenizer(url,":");
//       if( ! tokenizer.hasMoreTokens()) {
//           throw new IllegalArgumentException("ERROR:Connector.open(...):Parameter 'url' has no schema.url:"+url);
//       }
//       String schema = tokenizer.nextToken();
//       Class connectionImplementation = (Class)schemaToConnectionImplementationMapping.get(schema);
//       if(connectionImplementation == null) {
//           throw new ConnectionNotFoundException("No connection possible for given schema.schema:"+schema);
//       }
//       if(! Connection.class.isAssignableFrom(connectionImplementation)){
//           throw new ConnectionNotFoundException("INTERNAL ERROR:Found connection for schema is no subclass of Connection.");
//       }
//       try {
//           Constructor constructor = connectionImplementation.getConstructor(new Class[]{String.class});
//           Connection connection = (Connection)constructor.newInstance(new Object[] {url});
//           return connection;
//       }
//       catch(IOException e) {
//           
//       }
//       catch(Exception e) {
//           System.err.println("ERROR:Connector.open(...):Count not instanciate class.class:"+connectionImplementation+".exception:"+e);
//       }
//       return null;
        
//       if(url.startsWith("http") | url.startsWith("https")) {
//           return new HttpConnectionImpl(url);
//       }
//        return null;
        
        URL urlObject = urlObjectFromString(url);
        return new HttpConnectionImpl(urlObject);
	}


    private static URL urlObjectFromString(String url) throws ConnectionNotFoundException {
        URL urlObject;
        try {
            urlObject = new URL(url);
        }
        catch(MalformedURLException exception) {
            throw new ConnectionNotFoundException("Error: the parameter 'url' is malformed.url:"+url);
        }
        //TODO: This could be a method so checking is seperated from generating the url.
        if( ! ("http".equals(urlObject.getProtocol()) | "https".equals(urlObject.getProtocol()))){
            throw new ConnectionNotFoundException("Only http or https supported.");
        }
        return urlObject;
    }


	/**
	 * Create and open a Connection.
	 * 
	 * @param name - The URL for the connection.
	 * @param mode - The access mode.
	 * @return A new Connection object.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the requested connection cannot be make, or the protocol type does not exist.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static Connection open( String name, int mode) throws IOException{
        URL url = urlObjectFromString(name);
        return new HttpConnectionImpl(url,mode);
	}

	/**
	 * Create and open a Connection.
	 * 
	 * @param name - The URL for the connection
	 * @param mode - The access mode
	 * @param timeouts - A flag to indicate that the caller  wants timeout exceptions
	 * @return A new Connection object
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - if the requested connection cannot be make, or the protocol type does not exist.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static Connection open( String name, int mode, boolean timeouts) throws IOException{
        //TODO: Discard timeout flag as no handheld actually implements it reliably.
		return open(name,mode);
	}

	/**
	 * Create and open a connection input stream.
	 * 
	 * @param name - The URL for the connection.
	 * @return A DataInputStream.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the connection cannot be found.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static DataInputStream openDataInputStream(String name) throws IOException{
		if (name.startsWith("http://")) {
	        HttpConnection connection = (HttpConnection)open(name);
	        return connection.openDataInputStream();			
		} else {
			throw new ConnectionNotFoundException("Connection not found: " + name );
		}
	}

	/**
	 * Create and open a connection output stream.
	 * 
	 * @param name - The URL for the connection.
	 * @return A DataOutputStream.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the connection cannot be found.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static DataOutputStream openDataOutputStream( String name) throws IOException{
        HttpConnection connection = (HttpConnection)open(name);
        return connection.openDataOutputStream();
	}

	/**
	 * Create and open a connection input stream.
	 * 
	 * @param name - The URL for the connection.
	 * @return An InputStream.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the connection cannot be found.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static InputStream openInputStream( String name) throws IOException{
        HttpConnection connection = (HttpConnection)open(name);
        return connection.openInputStream();
	}

	/**
	 * Create and open a connection output stream.
	 * 
	 * @param name - The URL for the connection.
	 * @return An OutputStream.
	 * @throws IllegalArgumentException - If a parameter is invalid.
	 * @throws ConnectionNotFoundException - If the connection cannot be found.
	 * @throws IOException - If some other kind of I/O error occurs.
	 */
	public static OutputStream openOutputStream(String name) throws IOException
	{
        HttpConnection connection = (HttpConnection)open(name);
        return connection.openOutputStream();
	}

}
