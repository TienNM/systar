--[[
  description:地图层。
  author:wp_g4
  date:2011/12/18
--]]

--类结构定义
clsTiledLayer={}
setmetatable(clsTiledLayer,clsUILayer)
clsTiledLayer.__index=clsTiledLayer

--字段
clsTiledLayer.bufferedPainter=nil  	--缓冲画笔
clsTiledLayer.bufferBound=1        	--缓冲边缘宽度（单位：单元格）
clsTiledLayer.map=nil				--地图
clsTiledLayer.layers=nil           	--贴图层数据
clsTiledLayer.viewport=nil         --当前相机取景区域（视口）（单位：像素）

clsTiledLayer.bufferRow=nil        --缓冲区起始行号（单位：单元格）
clsTiledLayer.bufferCol=nil        --缓冲区起始列号（单位：单元格）
clsTiledLayer.bufferColNum=nil     --缓冲区宽度（单位：单元格）
clsTiledLayer.bufferRowNum=nil     --缓冲区高度（单位：单元格）


--构造器
function clsTiledLayer:new(x,y,width,height)
  local self = clsUILayer:new(x,y,width,height)
  setmetatable(self,clsTiledLayer)
  return self
end

--设置帖图数据
function clsTiledLayer:init(mapId,layers,viewport)
  self.map=Dictionary:getMap(mapId)
  self.layers=layers
  self.viewport=viewport
  --计算缓冲区大小
  self.bufferColNum=(math.ceil(self.width/self.map.cellWidth)+self.bufferBound)
  self.bufferRowNum=(math.ceil(self.height/self.map.cellHeight)+self.bufferBound)
  --创建缓冲
  self.image=Image:createImage(self.bufferColNum*self.map.cellWidth,self.bufferRowNum*self.map.cellHeight)
  self.bufferedPainter=self.image:getPainter()
  --根据当前视口计算缓冲区起始行、列号
  self.bufferCol=math.floor(self.viewport.x/self.map.cellWidth)
  self.bufferRow=math.floor(self.viewport.y/self.map.cellHeight)
  --绘制缓冲图
  local paintRect={col=0,row=0,colNum=self.bufferColNum,rowNum=self.bufferRowNum}
  self:refreshBuffer(paintRect,false)
end

--绘制自身
function clsTiledLayer:paintLayer(painter)
  --绘图
  painter:drawImage(self.image,self.viewport.x-self.bufferCol*self.map.cellWidth,self.viewport.y-self.bufferRow*self.map.cellHeight,
     self.viewport.width,self.viewport.height,0,0,UIConst.anchor.LT)
end

function clsTiledLayer:onTouch(x,y,type)
  if self.delegate and type==UIConst.eventType.DOWN then
    smLog:info("地图被点击,物理坐标: x="..x.." y="..y)
    self.delegate:mapTapped(self,math.floor((self.viewport.y+y)/self.map.cellHeight)+1,math.floor((self.viewport.x+x)/self.map.cellWidth)+1)
  end
end

--更新
function clsTiledLayer:trackViewport(viewport)
  self.viewport=viewport
  --根据窗口坐标和缓冲坐标判断是否需要更新缓冲
  if self.viewport.x<self.bufferCol*self.map.cellWidth then
    --缓冲左越界
      --smLog:info("--left--")
      --(1)复制可用区域
      self.image:copyArea(0,0,(self.bufferColNum-1)*self.map.cellWidth,self.bufferRowNum*self.map.cellHeight,self.map.cellWidth,0)
      --(2)修正缓冲区坐标(左移)
      self.bufferCol=self.bufferCol-1
      --(3)重绘新区域
      local refreshBufferRect={col=0,row=0,colNum=1,rowNum=self.bufferRowNum}
      self:refreshBuffer(refreshBufferRect,true)
  elseif self.viewport.x+self.width>(self.bufferCol+self.bufferColNum)*self.map.cellWidth then
    --缓冲右越界
      --smLog:info("--right--")
      --(1)复制可用区域
      self.image:copyArea(self.map.cellWidth,0,(self.bufferColNum-1)*self.map.cellWidth,self.bufferRowNum*self.map.cellHeight,0,0)
      --(2)修正缓冲区坐标(右移)
      self.bufferCol=self.bufferCol+1
      --(3)重绘新区域
      local refreshBufferRect={col=self.bufferColNum-1,row=0,colNum=1,rowNum=self.bufferRowNum}
      self:refreshBuffer(refreshBufferRect,true)
  elseif self.viewport.y<self.bufferRow*self.map.cellHeight then
    --缓冲上越界
      --smLog:info("--up--")
      --(1)复制可用区域
      self.image:copyArea(0,0,self.bufferColNum*self.map.cellWidth,(self.bufferRowNum-1)*self.map.cellHeight,0,self.map.cellHeight)
      --(2)修正缓冲区坐标(左移)
      self.bufferRow=self.bufferRow-1
      --(3)重绘新区域
      local refreshBufferRect={col=0,row=0,colNum=self.bufferColNum,rowNum=1}
      self:refreshBuffer(refreshBufferRect,true)
  elseif self.viewport.y+self.height>(self.bufferRow+self.bufferRowNum)*self.map.cellHeight then
    --缓冲下越界
      --smLog:info("--down--")
      --(1)复制可用区域
      self.image:copyArea(0,self.map.cellHeight,self.bufferColNum*self.map.cellWidth,(self.bufferRowNum-1)*self.map.cellHeight,0,0)
      --(2)修正缓冲区坐标(下移)
      self.bufferRow=self.bufferRow+1
      --(3)重绘新区域
      local refreshBufferRect={col=0,row=self.bufferRowNum-1,colNum=self.bufferColNum,rowNum=1}
      self:refreshBuffer(refreshBufferRect,true)
  end
end

--绘制缓冲区
function clsTiledLayer:refreshBuffer(rect,clearFlag)
  --清除
  if clearFlag then
    self.image:clear(rect.col*self.map.cellWidth,rect.row*self.map.cellHeight,
       rect.colNum*self.map.cellWidth,rect.rowNum*self.map.cellHeight)
  end
  --绘制
  for i=1,table.getn(self.layers) do
    local layer=self.layers[i]
    for j=rect.row,rect.row+rect.rowNum-1 do
      for k=rect.col,rect.col+rect.colNum-1 do
        --smLog:info("j="..j.." k="..k)
        local row=self.bufferRow+j+1
        local col=self.bufferCol+k+1
        if row>=1 and row<=self.map.rowNum and col>=1 and col<=self.map.colNum then
          local cell=layer[row][col]
          local imageSetId=cell[1]
          local tiledIndex=cell[2]
          if imageSetId~=-1 then
            local imgColNum=self.imageSets[imageSetId]:getWidth()/self.map.cellWidth
            local imgsx=math.mod(tiledIndex,imgColNum)*self.map.cellWidth
            local imgsy=math.floor(tiledIndex/imgColNum)*self.map.cellWidth
            self.bufferedPainter:drawImage(self.imageSets[imageSetId],imgsx,imgsy,self.map.cellWidth,self.map.cellHeight,
                 k*self.map.cellWidth,j*self.map.cellHeight,UIConst.anchor.LT)
          end
        end
      end
    end
  end
end

function clsTiledLayer:toString()
  local str="clsTiledLayer:["
  str=str.."x="..self.x.." y="..self.y.." w="..self.width.." h="..self.height
  str=str.."]"
  return str
end


